<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Task-count Normalized Sankey</title>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

<style>
body{
  margin:0;
  padding:24px;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}
svg{
  width:1600px;
  height:900px;
  border:1px solid #e8e8e8;
  border-radius:12px;
  background:#fff;
}
.links path{
  fill:none;
  stroke-opacity:0.6;
  mix-blend-mode:multiply;
}
.nodes rect{
  stroke:rgba(0,0,0,0.18);
  stroke-width:0.6px;
  rx:2; ry:2;
}
.nodes text{
  font-size:11px;
  pointer-events:none;
}
.col-header{
  font-size:22px;
  font-weight:900;
}
</style>
</head>

<body>
<h2>Studies → Tasks → Categories (Task-count based)</h2>
<svg id="viz" viewBox="0 0 1600 900"></svg>

<script>
const width = 1600, height = 900;
const svg = d3.select("#viz");

d3.json("modified_visualization_data.json").then(raw => {

  /* =====================================================
     1) COPY NODES
     ===================================================== */
  const nodes = raw.nodes.map(d => ({...d}));

  /* =====================================================
     2) REBUILD LINKS: EACH TASK = 1 UNIT
     ===================================================== */
  const isStudy = id => id.startsWith("Study ");
  const isTask  = id => id.startsWith("T");
  const isCat   = id => /^\d+\.\s/.test(id);

  let links = [];

  // Study → Task (1 per task)
  raw.links.forEach(l => {
    if (isStudy(l.source) && isTask(l.target)) {
      links.push({ source: l.source, target: l.target, value: 1 });
    }
  });

  // Task → Category (1 per task-category mapping)
  raw.links.forEach(l => {
    if (isTask(l.source) && isCat(l.target)) {
      links.push({ source: l.source, target: l.target, value: 1 });
    }
  });

  /* =====================================================
     3) STRICT ORDERING
     ===================================================== */
  const studyOrder = d3.sort(
    nodes.filter(d=>d.group==="study"),
    d => +d.id.replace("Study ","")
  ).map(d=>d.id);

  const taskOrder = d3.sort(
    nodes.filter(d=>d.group==="task"),
    d => +d.id.match(/\d+/)[0]
  ).map(d=>d.id);

  const categoryOrder = d3.sort(
    nodes.filter(d=>d.group==="category"),
    d => +d.id.match(/^\d+/)[0]
  ).map(d=>d.id);

  const orderIndex = new Map(
    [...studyOrder, ...taskOrder, ...categoryOrder]
      .map((id,i)=>[id,i])
  );

  /* =====================================================
     4) COLORS (UNIQUE STUDY & CATEGORY)
     ===================================================== */
  const studyColors = d3.quantize(d3.interpolateRainbow, studyOrder.length);
  const categoryColors = d3.quantize(d3.interpolateRainbow, categoryOrder.length);

  const studyColor = new Map(studyOrder.map((id,i)=>[id,studyColors[i]]));
  const categoryColor = new Map(categoryOrder.map((id,i)=>[id,categoryColors[i]]));

  const nodeColor = d => {
    if (d.group==="study") return studyColor.get(d.id);
    if (d.group==="category") return categoryColor.get(d.id);
    return "#0c7f86"; // task
  };

  const linkColor = d => {
    const s = d.source.id || d.source;
    const t = d.target.id || d.target;
    if (isStudy(s)) return studyColor.get(s);
    if (isCat(t)) return categoryColor.get(t);
    return "#999";
  };

  /* =====================================================
     5) SANKEY (TRUE 100% HEIGHT)
     ===================================================== */
  const sankey = d3.sankey()
    .nodeId(d=>d.id)
    .nodeWidth(18)
    .nodePadding(2)
    .nodeAlign(d3.sankeyJustify)
    .nodeSort((a,b)=>orderIndex.get(a.id)-orderIndex.get(b.id))
    .extent([[40,70],[width-40,height-30]]);

  const graph = sankey({
    nodes: nodes.map(d=>({...d})),
    links: links.map(d=>({...d}))
  });

  /* =====================================================
     6) HEADERS
     ===================================================== */
  const headers = [
    {name:"Study", group:"study"},
    {name:"Task", group:"task"},
    {name:"Category", group:"category"}
  ];

  headers.forEach(h=>{
    const gNodes = graph.nodes.filter(n=>n.group===h.group);
    const x = d3.mean(gNodes,n=>(n.x0+n.x1)/2);
    svg.append("text")
      .attr("class","col-header")
      .attr("x",x)
      .attr("y",42)
      .attr("text-anchor","middle")
      .text(h.name);
  });

  /* =====================================================
     7) DRAW
     ===================================================== */
  svg.append("g")
    .attr("class","links")
    .attr("stroke-linecap","butt")
    .selectAll("path")
    .data(graph.links)
    .join("path")
    .attr("d",d3.sankeyLinkHorizontal())
    .attr("stroke",linkColor)
    .attr("stroke-width",d=>Math.max(1,d.width));

  const node = svg.append("g")
    .attr("class","nodes")
    .selectAll("g")
    .data(graph.nodes)
    .join("g");

  node.append("rect")
    .attr("x",d=>d.x0)
    .attr("y",d=>d.y0)
    .attr("width",d=>d.x1-d.x0)
    .attr("height",d=>d.y1-d.y0)
    .attr("fill",nodeColor);

  node.append("text")
    .attr("x",d=>d.x0-10)
    .attr("y",d=>(d.y0+d.y1)/2)
    .attr("dy","0.35em")
    .attr("text-anchor","end")
    .text(d=>d.id)
    .filter(d=>d.x0<width/2)
    .attr("x",d=>d.x1+10)
    .attr("text-anchor","start");

});
</script>
</body>
</html>
