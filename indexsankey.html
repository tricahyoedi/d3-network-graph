<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fully Normalized Alluvial Sankey</title>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

<style>
body{
  margin:0;
  padding:24px;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}
svg{
  width:1600px;
  height:900px;
  border:1px solid #e8e8e8;
  border-radius:12px;
  background:#fff;
}
.links path{
  fill:none;
  stroke-opacity:0.6;
  mix-blend-mode:multiply;
}
.nodes rect{
  stroke:rgba(0,0,0,0.18);
  stroke-width:0.6px;
  rx:2; ry:2;
}
.nodes text{
  font-size:11px;
  pointer-events:none;
}
.col-header{
  font-size:22px;
  font-weight:900;
}
</style>
</head>

<body>
<h2>Studies → Tasks → Categories (Fully Height-Normalized)</h2>
<svg id="viz" viewBox="0 0 1600 900"></svg>

<script>
const width = 1600, height = 900;
const svg = d3.select("#viz");

d3.json("modified_visualization_data.json").then(raw => {

  /* ---------- Helpers ---------- */
  const isStudy = id => id.startsWith("Study ");
  const isTask  = id => id.startsWith("T");
  const isCat   = id => /^\d+\.\s/.test(id);

  /* ---------- Nodes ---------- */
  const nodes = raw.nodes.map(d => ({...d}));

  /* ---------- Task counts ---------- */
  const studyTaskCount = d3.rollup(
    raw.links.filter(l => isStudy(l.source) && isTask(l.target)),
    v => v.length,
    l => l.source
  );

  const categoryTaskCount = d3.rollup(
    raw.links.filter(l => isTask(l.source) && isCat(l.target)),
    v => v.length,
    l => l.target
  );

  const tasks = nodes.filter(d => d.group === "task").map(d => d.id);
  const totalTasks = tasks.length;

  /* ---------- Rebuild links ---------- */
  let links = [];

  // Study → Task (each task = 1)
  raw.links.forEach(l => {
    if (isStudy(l.source) && isTask(l.target)) {
      links.push({ source:l.source, target:l.target, value:1 });
    }
  });

  // Task → Category (each task = 1)
  raw.links.forEach(l => {
    if (isTask(l.source) && isCat(l.target)) {
      links.push({ source:l.source, target:l.target, value:1 });
    }
  });

  /* ---------- BALANCING LINKS ---------- */
  // These make Study and Category fill 100% height
  studyTaskCount.forEach((count, study) => {
    const deficit = totalTasks - count;
    if (deficit > 0) {
      links.push({
        source: study,
        target: study,   // self-loop (layout only)
        value: deficit,
        _dummy: true
      });
    }
  });

  categoryTaskCount.forEach((count, cat) => {
    const deficit = totalTasks - count;
    if (deficit > 0) {
      links.push({
        source: cat,
        target: cat,
        value: deficit,
        _dummy: true
      });
    }
  });

  /* ---------- Ordering ---------- */
  const order = new Map();
  [
    ...nodes.filter(d=>d.group==="study").sort((a,b)=>+a.id.replace("Study ","")-+b.id.replace("Study ","")),
    ...nodes.filter(d=>d.group==="task").sort((a,b)=>+a.id.match(/\d+/)-+b.id.match(/\d+/)),
    ...nodes.filter(d=>d.group==="category").sort((a,b)=>+a.id.match(/^\d+/)-+b.id.match(/^\d+/))
  ].forEach((d,i)=>order.set(d.id,i));

  /* ---------- Colors ---------- */
  const studyIds = nodes.filter(d=>d.group==="study").map(d=>d.id);
  const catIds   = nodes.filter(d=>d.group==="category").map(d=>d.id);

  const studyColor = new Map(
    studyIds.map((id,i)=>[id,d3.interpolateRainbow(i/studyIds.length)])
  );
  const catColor = new Map(
    catIds.map((id,i)=>[id,d3.interpolateRainbow(i/catIds.length)])
  );

  const nodeColor = d =>
    d.group==="study" ? studyColor.get(d.id) :
    d.group==="category" ? catColor.get(d.id) :
    "#0c7f86";

  const linkColor = d => {
    if (d._dummy) return "transparent";
    const s = d.source.id || d.source;
    const t = d.target.id || d.target;
    if (isStudy(s)) return studyColor.get(s);
    if (isCat(t)) return catColor.get(t);
    return "#999";
  };

  /* ---------- Sankey ---------- */
  const sankey = d3.sankey()
    .nodeId(d=>d.id)
    .nodeWidth(18)
    .nodePadding(2)
    .nodeAlign(d3.sankeyJustify)
    .nodeSort((a,b)=>order.get(a.id)-order.get(b.id))
    .extent([[40,70],[width-40,height-30]]);

  const graph = sankey({
    nodes: nodes.map(d=>({...d})),
    links: links.map(d=>({...d}))
  });

  /* ---------- Headers ---------- */
  ["Study","Task","Category"].forEach((h,i)=>{
    const g = ["study","task","category"][i];
    const gNodes = graph.nodes.filter(n=>n.group===g);
    const x = d3.mean(gNodes,n=>(n.x0+n.x1)/2);
    svg.append("text")
      .attr("class","col-header")
      .attr("x",x)
      .attr("y",42)
      .attr("text-anchor","middle")
      .text(h);
  });

  /* ---------- Draw ---------- */
  svg.append("g")
    .attr("class","links")
    .selectAll("path")
    .data(graph.links)
    .join("path")
    .attr("d",d3.sankeyLinkHorizontal())
    .attr("stroke",linkColor)
    .attr("stroke-width",d=>d._dummy?0:Math.max(1,d.width));

  const node = svg.append("g")
    .attr("class","nodes")
    .selectAll("g")
    .data(graph.nodes)
    .join("g");

  node.append("rect")
    .attr("x",d=>d.x0)
    .attr("y",d=>d.y0)
    .attr("width",d=>d.x1-d.x0)
    .attr("height",d=>d.y1-d.y0)
    .attr("fill",nodeColor);

  node.append("text")
    .attr("x",d=>d.x0-10)
    .attr("y",d=>(d.y0+d.y1)/2)
    .attr("dy","0.35em")
    .attr("text-anchor","end")
    .text(d=>d.id)
    .filter(d=>d.x0<width/2)
    .attr("x",d=>d.x1+10)
    .attr("text-anchor","start");

});
</script>
</body>
</html>
