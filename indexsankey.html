<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title> Sankey </title>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

<style>
body{
  margin:0;
  padding:24px;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}
svg{
  width:1600px;
  height:900px;
  border:1px solid #e8e8e8;
  border-radius:12px;
  background:#fff;
}
.links path{
  fill:none;
  stroke-opacity:0.6;
  mix-blend-mode:multiply;
}
.nodes rect{
  stroke:rgba(0,0,0,0.18);
  stroke-width:0.6px;
  rx:2; ry:2;
}
.nodes text{
  font-size:11px;
  pointer-events:none;
}
.col-header{
  font-size:22px;
  font-weight:900;
}
</style>
</head>

<body>
<h2>Studies → Tasks → Categories </h2>
<svg id="viz" viewBox="0 0 1600 900"></svg>

<script>
const width = 1600, height = 900;
const svg = d3.select("#viz");

d3.json("modified_visualization_data.json").then(raw => {

  /* ---------- Helpers ---------- */
  const isStudy = id => id.startsWith("Study ");
  const isTask  = id => id.startsWith("T");
  const isCat   = id => /^\d+\.\s/.test(id);

  /* ---------- Copy nodes ---------- */
  const nodes = raw.nodes.map(d => ({...d}));

  /* ---------- Count tasks ---------- */
  const studyCount = d3.rollup(
    raw.links.filter(l => isStudy(l.source) && isTask(l.target)),
    v => v.length,
    l => l.source
  );

  const catCount = d3.rollup(
    raw.links.filter(l => isTask(l.source) && isCat(l.target)),
    v => v.length,
    l => l.target
  );

  const tasks = nodes.filter(d => d.group === "task").map(d => d.id);
  const totalTasks = tasks.length;

  /* ---------- Build links (task = 1 unit) ---------- */
  let links = [];

  raw.links.forEach(l => {
    if (isStudy(l.source) && isTask(l.target))
      links.push({ source:l.source, target:l.target, value:1 });

    if (isTask(l.source) && isCat(l.target))
      links.push({ source:l.source, target:l.target, value:1 });
  });

  /* ---------- ADD BALANCING NODES ---------- */
  const STUDY_BAL = "__study_balance__";
  const CAT_BAL   = "__category_balance__";

  nodes.push({ id: STUDY_BAL, group:"balance" });
  nodes.push({ id: CAT_BAL, group:"balance" });

  // Balance Study column
  studyCount.forEach((count, study) => {
    const deficit = totalTasks - count;
    if (deficit > 0) {
      links.push({
        source: study,
        target: STUDY_BAL,
        value: deficit,
        _dummy: true
      });
    }
  });

  // Balance Category column
  catCount.forEach((count, cat) => {
    const deficit = totalTasks - count;
    if (deficit > 0) {
      links.push({
        source: CAT_BAL,
        target: cat,
        value: deficit,
        _dummy: true
      });
    }
  });

  /* ---------- Ordering ---------- */
  const ordered = [
    ...nodes.filter(d=>d.group==="study").sort((a,b)=>+a.id.replace("Study ","")-+b.id.replace("Study ","")),
    ...nodes.filter(d=>d.group==="task").sort((a,b)=>+a.id.match(/\d+/)-+b.id.match(/\d+/)),
    ...nodes.filter(d=>d.group==="category").sort((a,b)=>+a.id.match(/^\d+/)-+b.id.match(/^\d+/))
  ];

  const orderIndex = new Map(ordered.map((d,i)=>[d.id,i]));

  /* ---------- Colors ---------- */
  const studyIds = ordered.filter(d=>d.group==="study").map(d=>d.id);
  const catIds   = ordered.filter(d=>d.group==="category").map(d=>d.id);

  const studyColor = new Map(studyIds.map((id,i)=>[id,d3.interpolateRainbow(i/studyIds.length)]));
  const catColor   = new Map(catIds.map((id,i)=>[id,d3.interpolateRainbow(i/catIds.length)]));

  const nodeColor = d => {
    if (d.group==="study") return studyColor.get(d.id);
    if (d.group==="category") return catColor.get(d.id);
    if (d.group==="task") return "#0c7f86";
    return "transparent";
  };

  const linkColor = d => {
    if (d._dummy) return "transparent";
    const s = d.source.id || d.source;
    const t = d.target.id || d.target;
    if (isStudy(s)) return studyColor.get(s);
    if (isCat(t)) return catColor.get(t);
    return "#999";
  };

  /* ---------- Sankey ---------- */
  const sankey = d3.sankey()
    .nodeId(d=>d.id)
    .nodeWidth(18)
    .nodePadding(2)
    .nodeAlign(d3.sankeyJustify)
    .nodeSort((a,b)=>orderIndex.get(a.id)-orderIndex.get(b.id))
    .extent([[40,70],[width-40,height-30]]);

  const graph = sankey({
    nodes: nodes.map(d=>({...d})),
    links: links.map(d=>({...d}))
  });

  /* ---------- Headers ---------- */
  [["Study","study"],["Task","task"],["Category","category"]].forEach(([label,grp])=>{
    const gNodes = graph.nodes.filter(n=>n.group===grp);
    const x = d3.mean(gNodes,n=>(n.x0+n.x1)/2);
    svg.append("text")
      .attr("class","col-header")
      .attr("x",x)
      .attr("y",42)
      .attr("text-anchor","middle")
      .text(label);
  });

  /* ---------- Draw ---------- */
  svg.append("g")
    .attr("class","links")
    .selectAll("path")
    .data(graph.links.filter(d=>!d._dummy))
    .join("path")
    .attr("d",d3.sankeyLinkHorizontal())
    .attr("stroke",linkColor)
    .attr("stroke-width",d=>Math.max(1,d.width));

  const node = svg.append("g")
    .attr("class","nodes")
    .selectAll("g")
    .data(graph.nodes.filter(d=>d.group!=="balance"))
    .join("g");

  node.append("rect")
    .attr("x",d=>d.x0)
    .attr("y",d=>d.y0)
    .attr("width",d=>d.x1-d.x0)
    .attr("height",d=>d.y1-d.y0)
    .attr("fill",nodeColor);

  node.append("text")
    .attr("x",d=>d.x0-10)
    .attr("y",d=>(d.y0+d.y1)/2)
    .attr("dy","0.35em")
    .attr("text-anchor","end")
    .text(d=>d.id)
    .filter(d=>d.x0<width/2)
    .attr("x",d=>d.x1+10)
    .attr("text-anchor","start");

});
</script>
</body>
</html>
