<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Normalized Block Sankey</title>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

<style>
body{
  margin:0;
  padding:24px;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}
svg{
  width:1600px;
  height:900px;
  border:1px solid #e8e8e8;
  border-radius:12px;
  background:#fff;
}
.links path{
  fill:none;
  stroke-opacity:0.6;
  mix-blend-mode:multiply;
}
.nodes rect{
  stroke:rgba(0,0,0,0.18);
  stroke-width:0.6px;
  rx:2; ry:2;
}
.nodes text{
  font-size:11px;
  pointer-events:none;
}
.col-header{
  font-size:22px;
  font-weight:900;
}
</style>
</head>

<body>
<h2>Studies → Tasks → Categories (Fully Normalized)</h2>
<svg id="viz" viewBox="0 0 1600 900"></svg>

<script>
const width = 1600, height = 900;
const svg = d3.select("#viz");

d3.json("modified_visualization_data.json").then(raw => {

  let nodes = raw.nodes.map(d => ({...d}));
  let links = raw.links.map(d => ({...d}));

  /* ======================================================
     1) STRICT ORDERING (top → bottom)
     ====================================================== */

  const studyOrder = d3.sort(
    nodes.filter(d=>d.group==="study"),
    d => +d.id.replace("Study ","")
  ).map(d=>d.id);

  const taskOrder = d3.sort(
    nodes.filter(d=>d.group==="task"),
    d => +d.id.match(/\d+/)[0]
  ).map(d=>d.id);

  const categoryOrder = d3.sort(
    nodes.filter(d=>d.group==="category"),
    d => +d.id.match(/^\d+/)[0]
  ).map(d=>d.id);

  const orderIndex = new Map();
  [...studyOrder, ...taskOrder, ...categoryOrder]
    .forEach((id,i)=>orderIndex.set(id,i));

  /* ======================================================
     2) NORMALIZE FLOWS SO ALL COLUMNS = 100% HEIGHT
     ====================================================== */

  const isStudy  = id => id.startsWith("Study ");
  const isTask   = id => id.startsWith("T");
  const isCat    = id => /^\d+\.\s/.test(id);

  const studyLinks = links.filter(l => isStudy(l.source) && isTask(l.target));
  const taskLinks  = links.filter(l => isTask(l.source)  && isCat(l.target));

  const sumStudy = d3.sum(studyLinks, d=>d.value);
  const sumTask  = d3.sum(taskLinks,  d=>d.value);

  const studyScale = sumStudy > 0 ? sumTask / sumStudy : 1;

  links = links.map(l=>{
    if(isStudy(l.source) && isTask(l.target)){
      return {...l, value: l.value * studyScale};
    }
    return l;
  });

  // Recalculate after scaling study
  const newStudySum = d3.sum(
    links.filter(l=>isStudy(l.source) && isTask(l.target)),
    d=>d.value
  );

  const catScale = newStudySum > 0 ? newStudySum / sumTask : 1;

  links = links.map(l=>{
    if(isTask(l.source) && isCat(l.target)){
      return {...l, value: l.value * catScale};
    }
    return l;
  });

  /* ======================================================
     3) COLOR MAPS (unique Study & Category)
     ====================================================== */

  const studyColors = d3.quantize(d3.interpolateRainbow, studyOrder.length);
  const categoryColors = d3.quantize(d3.interpolateRainbow, categoryOrder.length);

  const studyColor = new Map(studyOrder.map((id,i)=>[id,studyColors[i]]));
  const categoryColor = new Map(categoryOrder.map((id,i)=>[id,categoryColors[i]]));

  const linkColor = d => {
    const s = d.source.id || d.source;
    const t = d.target.id || d.target;
    if(isStudy(s)) return studyColor.get(s);
    if(isCat(t)) return categoryColor.get(t);
    return "#999";
  };

  const nodeColor = d => {
    if(d.group==="study") return studyColor.get(d.id);
    if(d.group==="category") return categoryColor.get(d.id);
    return "#0c7f86"; // task
  };

  /* ======================================================
     4) SANKEY (no auto-reordering)
     ====================================================== */

  const sankey = d3.sankey()
    .nodeId(d=>d.id)
    .nodeWidth(18)
    .nodePadding(2)
    .nodeAlign(d3.sankeyJustify)
    .nodeSort((a,b)=>orderIndex.get(a.id)-orderIndex.get(b.id))
    .extent([[40,70],[width-40,height-30]]);

  const graph = sankey({
    nodes: nodes.map(d=>({...d})),
    links: links.map(d=>({...d}))
  });

  /* ======================================================
     5) HEADERS
     ====================================================== */
  const headers = [
    {name:"Study",    group:"study"},
    {name:"Task",     group:"task"},
    {name:"Category", group:"category"}
  ];

  headers.forEach(h=>{
    const gNodes = graph.nodes.filter(n=>n.group===h.group);
    const x = d3.mean(gNodes,n=>(n.x0+n.x1)/2);
    svg.append("text")
      .attr("class","col-header")
      .attr("x",x)
      .attr("y",42)
      .attr("text-anchor","middle")
      .text(h.name);
  });

  /* ======================================================
     6) DRAW
     ====================================================== */

  svg.append("g")
    .attr("class","links")
    .attr("stroke-linecap","butt")
    .selectAll("path")
    .data(graph.links)
    .join("path")
    .attr("d",d3.sankeyLinkHorizontal())
    .attr("stroke",linkColor)
    .attr("stroke-width",d=>Math.max(1,d.width));

  const node = svg.append("g")
    .attr("class","nodes")
    .selectAll("g")
    .data(graph.nodes)
    .join("g");

  node.append("rect")
    .attr("x",d=>d.x0)
    .attr("y",d=>d.y0)
    .attr("width",d=>d.x1-d.x0)
    .attr("height",d=>d.y1-d.y0)
    .attr("fill",nodeColor);

  node.append("text")
    .attr("x",d=>d.x0-10)
    .attr("y",d=>(d.y0+d.y1)/2)
    .attr("dy","0.35em")
    .attr("text-anchor","end")
    .text(d=>d.id)
    .filter(d=>d.x0<width/2)
    .attr("x",d=>d.x1+10)
    .attr("text-anchor","start");

});
</script>
</body>
</html>
